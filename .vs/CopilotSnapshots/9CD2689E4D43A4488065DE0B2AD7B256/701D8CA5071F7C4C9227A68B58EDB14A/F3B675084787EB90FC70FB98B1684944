// HUD Frame Update Script (Enhanced with Boss Mode Support)
// Provides DOM-based HUD that replaces canvas-based HUD
// Updates health, ammo, score, and manages boss HP bar transitions

console.log("[HUD FRAME] Initializing enhanced HUD with boss mode support...");

// Debug function for immediate testing
window.debugHUDForce = function() {
  console.log("=== FORCE HUD DEBUG ===");
  
  // Force show HUD
  const hudEl = document.getElementById('screen-hud');
  if (hudEl) {
    hudEl.classList.remove('hidden');
    hudEl.removeAttribute('aria-hidden');
    hudEl.style.display = 'block';
    hudEl.style.opacity = '1';
    hudEl.style.visibility = 'visible';
    hudEl.style.background = 'rgba(255, 0, 0, 0.2)'; // Red debug tint
    console.log("HUD element forced visible with debug tint");
  } else {
    console.log("HUD element NOT FOUND");
    return;
  }
  
  // Force update all values
  const elements = {
    'hud-round': '05',
    'hud-sector': 'DEBUG',
    'hud-score': '123456',
    'hud-health-value': '75',
    'hud-ammo-value': '42'
  };
  
  Object.entries(elements).forEach(([id, value]) => {
    const el = document.getElementById(id);
    if (el) {
      el.textContent = value;
      el.style.color = '#ffffff';
      el.style.fontSize = '12px';
      el.style.fontFamily = "'Press Start 2P', monospace";
      el.style.display = 'inline';
      el.style.visibility = 'visible';
      el.style.opacity = '1';
      console.log(`Updated ${id} to: ${value}`);
    } else {
      console.log(`Element ${id} NOT FOUND`);
    }
  });
  
  // Force HP bar
  const hpFill = document.getElementById('hud-hp-fill');
  if (hpFill) {
    hpFill.style.width = '75%';
    hpFill.style.background = '#e53e3e';
    console.log("HP bar updated to 75%");
  }
  
  // Force ammo pips
  const pips = document.querySelectorAll('#hud-ammo-pips .pip');
  pips.forEach((pip, i) => {
    pip.style.display = 'block';
    pip.style.visibility = 'visible';
    pip.style.opacity = '1';
    if (i < 3) {
      pip.classList.add('on');
      pip.style.background = '#ffc107';
    } else {
      pip.classList.remove('on');
      pip.style.background = '#333333';
    }
  });
  console.log(`Updated ${pips.length} ammo pips`);
  
  // Force game state
  if (window.state) {
    window.state.gameStarted = true;
    window.state.health = 75;
    window.state.ammo = 42;
    window.state.score = 123456;
    window.state.round = 5;
    window.state.sector = 'DEBUG';
    console.log("Game state forced to debug values");
  }
  
  console.log("=== FORCE HUD DEBUG COMPLETE ===");
};

(function(){
  console.log("[HUD] Auto-updater initializing...");
  
  // Quick selectors
  const qs = (id) => document.getElementById(id);
  
  // Track previous values to avoid unnecessary DOM updates
  let prev = { health: null, ammo: null, score: null, round: null, sector: null };
  let prevBoss = { active: false, name: null, health: null, maxHealth: null };
  
  // Get contextual objective text based on sector and boss status
  function getObjectiveForSector(sector, bossActive, round) {
    if (bossActive) {
      return "ELIMINATE BOSS";
    }
    
    const objectives = {
      'ALPHA': round > 3 ? 'ADVANCE SECTOR' : 'SECURE PERIMETER',
      'BRAVO': round > 5 ? 'LOCATE INTEL' : 'CLEAR HOSTILES', 
      'CHARLIE': round > 7 ? 'EXTRACT VIP' : 'DEFEND POSITION',
      'DELTA': 'FINAL ASSAULT',
      'ECHO': 'MISSION COMPLETE',
    };
    return objectives[sector] || 'SURVIVE';
  }
  
  // Enhanced ammo pip management
  function setAmmoPips(filledCount, totalPips = 6) {
    const pips = document.querySelectorAll('#hud-ammo-pips .pip');
    pips.forEach((pip, i) => {
      if (i < filledCount) {
        pip.classList.add('on');
      } else {
        pip.classList.remove('on');
      }
    });
  }
  
  // Boss mode management
  function updateBossMode() {
    const S = (window.state || (window.game && window.game.state));
    if (!S) return;
    
    const hudContainer = qs('screen-hud');
    const boss = S.boss;
    const bossActive = boss && boss.isAlive && boss.health > 0;
    
    if (!hudContainer) return;
    
    // Toggle boss mode class
    if (bossActive && !hudContainer.classList.contains('boss-mode')) {
      console.log("[HUD] Entering boss mode");
      hudContainer.classList.add('boss-mode');
      
      // Update boss info
      updateBossInfo(boss);
    } else if (!bossActive && hudContainer.classList.contains('boss-mode')) {
      console.log("[HUD] Exiting boss mode");
      hudContainer.classList.remove('boss-mode');
    }
    
    // Update boss HP if in boss mode
    if (bossActive) {
      updateBossInfo(boss);
    }
  }
  
  // Update boss HP bar and name
  function updateBossInfo(boss) {
    if (!boss) return;
    
    const nameEl = qs('boss-name-text');
    const fillEl = qs('boss-hp-fill');
    const textEl = qs('boss-hp-text');
    
    // Update boss name
    if (nameEl && boss.name !== prevBoss.name) {
      nameEl.textContent = boss.name || "UNKNOWN BOSS";
      prevBoss.name = boss.name;
    }
    
    // Update boss HP
    const currentHP = Math.max(0, Math.ceil(boss.health || 0));
    const maxHP = boss.maxHealth || 1000;
    const hpPercent = Math.max(0, Math.min(100, (currentHP / maxHP) * 100));
    
    if (fillEl && (currentHP !== prevBoss.health || maxHP !== prevBoss.maxHealth)) {
      fillEl.style.width = hpPercent + '%';
      
      // Change color based on HP percentage
      if (hpPercent > 60) {
        fillEl.style.background = 'linear-gradient(90deg, #ff6666, #ff4444)'; // Red
      } else if (hpPercent > 30) {
        fillEl.style.background = 'linear-gradient(90deg, #ff8844, #ff6622)'; // Orange
      } else {
        fillEl.style.background = 'linear-gradient(90deg, #ff2222, #cc1111)'; // Dark red
      }
      
      prevBoss.health = currentHP;
      prevBoss.maxHealth = maxHP;
    }
    
    // Update boss HP text
    if (textEl) {
      const hpText = `${currentHP}/${maxHP}`;
      if (textEl.textContent !== hpText) {
        textEl.textContent = hpText;
      }
    }
  }
  
  function tick() {
    try {
      const S = (window.state || (window.game && window.game.state)) || null;
      if (!S) {
        requestAnimationFrame(tick);
        return;
      }
      
      // IMMEDIATE DEBUG: Check if HUD elements exist and are visible
      if (!window._hudElementsChecked) {
        const hudEl = qs('screen-hud');
        const healthEl = qs('hud-health-value');
        const ammoEl = qs('hud-ammo-value');
        const scoreEl = qs('hud-score');
        
        console.log("[HUD DEBUG] Element check:", {
          hudExists: !!hudEl,
          hudVisible: hudEl ? !hudEl.classList.contains('hidden') : false,
          hudOpacity: hudEl ? hudEl.style.opacity : 'N/A',
          hudDisplay: hudEl ? hudEl.style.display : 'N/A',
          hudComputedDisplay: hudEl ? window.getComputedStyle(hudEl).display : 'N/A',
          healthEl: !!healthEl,
          healthElVisible: healthEl ? healthEl.offsetParent !== null : false,
          ammoEl: !!ammoEl,
          ammoElVisible: ammoEl ? ammoEl.offsetParent !== null : false,
          scoreEl: !!scoreEl,
          scoreElVisible: scoreEl ? scoreEl.offsetParent !== null : false,
          gameStarted: S.gameStarted
        });
        
        // FORCE VISIBLE IMMEDIATELY
        if (hudEl) {
          hudEl.classList.remove('hidden');
          hudEl.removeAttribute('aria-hidden');
          hudEl.style.display = 'block';
          hudEl.style.opacity = '1';
          hudEl.style.visibility = 'visible';
          hudEl.style.background = 'rgba(255, 0, 0, 0.1)'; // Debug red tint
          console.log("[HUD DEBUG] FORCED HUD VISIBLE with red debug tint");
        }
        
        window._hudElementsChecked = true;
      }
      
      // Force immediate updates every frame for first few seconds
      const forceUpdate = !window._hudStabilized && Date.now() - (window._hudStartTime || Date.now()) < 5000;
      if (!window._hudStartTime) window._hudStartTime = Date.now();
      
      // DEBUG: Log state updates to help identify HUD update issues
      const debugInfo = {
        health: S.health,
        ammo: S.ammo,
        score: S.score,
        round: S.round,
        sector: S.sector,
        gameStarted: S.gameStarted
      };
      
      // Only log every 60 frames to avoid spam (roughly 1 second)
      if (!window._hudDebugCounter) window._hudDebugCounter = 0;
      window._hudDebugCounter++;
      if (window._hudDebugCounter % 60 === 0) {
        console.log("[HUD DEBUG] State:", debugInfo);
      }
      
      // Handle boss mode transitions
      updateBossMode();
      
      // Update round display
      const round = S.round || S.currentRound || 1;
      if (round !== prev.round || forceUpdate) {
        const roundEl = qs('hud-round');
        if (roundEl) {
          const newText = String(round).padStart(2, '0');
          roundEl.textContent = newText;
          roundEl.style.fontFamily = "'Press Start 2P', monospace";
          roundEl.style.color = "#c7ffc7";
          roundEl.style.fontSize = "8px";
          roundEl.style.display = "inline";
          roundEl.style.visibility = "visible";
          console.log("[HUD DEBUG] Round updated to:", round, "->", newText);
        }
        prev.round = round;
      }
      
      // Update sector display
      const sector = S.sector || S.currentSector || 'ALPHA';
      if (sector !== prev.sector || forceUpdate) {
        const sectorEl = qs('hud-sector');
        if (sectorEl) {
          sectorEl.textContent = sector;
          sectorEl.style.fontFamily = "'Press Start 2P', monospace";
          sectorEl.style.color = "#c7ffc7";
          sectorEl.style.fontSize = "8px";
          sectorEl.style.display = "inline";
          sectorEl.style.visibility = "visible";
          console.log("[HUD DEBUG] Sector updated to:", sector);
        }
        prev.sector = sector;
      }
      
      // Update score with enhanced formatting
      const score = S.score || 0;
      if (score !== prev.score || forceUpdate) {
        const scoreEl = qs('hud-score');
        if (scoreEl) {
          const newText = String(score).padStart(6, '0');
          scoreEl.textContent = newText;
          scoreEl.style.fontFamily = "'Press Start 2P', monospace";
          scoreEl.style.color = "#c7ffc7";
          scoreEl.style.fontSize = "8px";
          scoreEl.style.display = "inline";
          scoreEl.style.visibility = "visible";
          scoreEl.style.opacity = "1";
          console.log("[HUD DEBUG] Score updated to:", score, "->", newText, "Element:", scoreEl);
        }
        prev.score = score;
      }
      
      // Update health bar with smooth color transitions
      const hp = S.health != null ? S.health : (S.playerHealth != null ? S.playerHealth : 100);
      if (hp !== prev.health || forceUpdate) {
        const fill = qs('hud-hp-fill');
        const valueEl = qs('hud-health-value');
        if (fill) {
          const pct = Math.max(0, Math.min(100, hp)) / 100;
          fill.style.width = (pct * 100) + '%';
          fill.style.display = "block";
          fill.style.visibility = "visible";
          fill.style.opacity = "1";
          
          // Enhanced color gradients based on health percentage
          if (pct > 0.7) {
            fill.style.background = 'linear-gradient(90deg, #4caf50, #2e7d32)'; // Green
          } else if (pct > 0.5) {
            fill.style.background = 'linear-gradient(90deg, #ff9800, #f57c00)'; // Orange
          } else if (pct > 0.3) {
            fill.style.background = 'linear-gradient(90deg, #ff5722, #d84315)'; // Red-orange
          } else {
            fill.style.background = 'linear-gradient(90deg, #f44336, #c62828)'; // Red
          }
        }
        if (valueEl) {
          const newText = String(Math.round(hp));
          valueEl.textContent = newText;
          valueEl.style.fontFamily = "'Press Start 2P', monospace";
          valueEl.style.color = "#c7ffc7";
          valueEl.style.fontSize = "8px";
          valueEl.style.display = "inline";
          valueEl.style.visibility = "visible";
          valueEl.style.opacity = "1";
          console.log("[HUD DEBUG] Health updated to:", hp, "->", newText, "Element:", valueEl);
        }
        prev.health = hp;
      }
      
      // Update ammo display and pips
      const ammo = (S.ammo != null ? S.ammo : S.playerAmmo != null ? S.playerAmmo : null);
      if (ammo !== prev.ammo || forceUpdate) {
        const ammoEl = qs('hud-ammo-value');
        if (ammoEl) {
          let newText;
          if (ammo === Infinity || ammo > 999) {
            newText = '?';
          } else {
            newText = String(ammo || 0);
          }
          ammoEl.textContent = newText;
          ammoEl.style.fontFamily = "'Press Start 2P', monospace";
          ammoEl.style.color = "#c7ffc7";
          ammoEl.style.fontSize = "8px";
          ammoEl.style.display = "inline";
          ammoEl.style.visibility = "visible";
          ammoEl.style.opacity = "1";
          console.log("[HUD DEBUG] Ammo updated to:", ammo, "->", newText, "Element:", ammoEl);
        }
        
        // Update ammo pips with improved calculation
        if (ammo === Infinity || ammo > 999) {
          setAmmoPips(6, 6); // Show all pips for infinite ammo
        } else {
          const ammoPerPip = 25;
          const pipsToShow = Math.max(0, Math.min(6, Math.ceil((ammo || 0) / ammoPerPip)));
          setAmmoPips(pipsToShow, 6);
        }
        prev.ammo = ammo;
      }
      
      // Update objective text based on narrative context
      const currentSector = S.sector || 'ALPHA';
      const currentRound = S.round || 1;
      const bossActive = S.boss && S.boss.isAlive;
      const newObjective = getObjectiveForSector(currentSector, bossActive, currentRound);
      
      const objEl = qs('hud-objective');
      if (objEl && (objEl.textContent !== newObjective || forceUpdate)) {
        objEl.textContent = newObjective;
        objEl.style.fontFamily = "'Press Start 2P', monospace";
        objEl.style.color = "#c7ffc7";
        objEl.style.fontSize = "8px";
        objEl.style.display = "inline";
        objEl.style.visibility = "visible";
      }
      
      // Mark as stabilized after a few updates
      if (!window._hudStabilized && window._hudDebugCounter > 120) { // 2 seconds
        window._hudStabilized = true;
        console.log("[HUD DEBUG] HUD updates stabilized");
      }
      
    } catch(e) { 
      console.warn("[HUD] Update error:", e);
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();

// HUD visibility management with smooth transitions
(function(){
  console.log("[HUD] Visibility manager initializing...");
  
  function toggleHudVisibility(){
    const hudEl = document.getElementById('screen-hud');
    if (!hudEl) {
      console.warn("[HUD] screen-hud element not found, retrying...");
      requestAnimationFrame(toggleHudVisibility);
      return;
    }
    
    const start = document.getElementById('start-screen');
    const menuVisible = !!(start && start.offsetParent !== null && start.style.display !== 'none');
    const S = (window.state || (window.game && window.game.state)) || null;
    const running = !!(S && S.gameStarted);
    
    // DEBUG: Log visibility state
    if (!window._visibilityDebugLogged) {
      console.log("[HUD DEBUG] Visibility check:", {
        hudEl: !!hudEl,
        menuVisible,
        running,
        gameStarted: S?.gameStarted,
        startScreenDisplay: start?.style?.display,
        startScreenOffsetParent: start?.offsetParent
      });
      window._visibilityDebugLogged = true;
      // Reset debug flag after 10 seconds
      setTimeout(() => { window._visibilityDebugLogged = false; }, 10000);
    }
    
    // ALWAYS SHOW HUD FOR DEBUGGING
    hudEl.classList.remove('hidden'); 
    hudEl.removeAttribute('aria-hidden');
    hudEl.style.opacity = '1';
    hudEl.style.display = 'block'; // Force display
    hudEl.style.visibility = 'visible'; // Force visibility
    hudEl.style.background = 'rgba(255, 0, 0, 0.1)'; // Debug red tint
    console.log("[HUD DEBUG] HUD FORCED visible for debugging");
    
    requestAnimationFrame(toggleHudVisibility);
  }
  
  toggleHudVisibility();
})();

// Initialize Press Start 2P font application and ensure visibility
(function(){
  const style = document.createElement('style');
  style.textContent = `
    #screen-hud * {
      font-family: 'Press Start 2P', monospace !important;
    }
    
    /* FORCE HUD elements to be visible - DEBUG */
    #screen-hud {
      display: block !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      background: rgba(255, 0, 0, 0.1) !important;
    }
    
    #screen-hud.hidden {
      display: block !important; /* Don't hide during debugging */
      opacity: 1 !important;
    }
    
    /* FORCE HUD values to be visible - DEBUG */
    #hud-score,
    #hud-health-value,
    #hud-ammo-value,
    #hud-round,
    #hud-sector,
    #hud-objective {
      display: inline !important;
      visibility: visible !important;
      opacity: 1 !important;
      color: #ffffff !important;
      font-size: 12px !important;
      font-family: 'Press Start 2P', monospace !important;
      background: rgba(0, 255, 0, 0.2) !important; /* Green debug background */
    }
    
    /* FORCE all HUD segments visible */
    .hud-seg, .hud-top, .hud-bottom, .hp-bar, .pips, .pip {
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    
    /* Fix any potential z-index issues */
    #screen-hud {
      z-index: 1000 !important;
      position: absolute !important;
    }
  `;
  document.head.appendChild(style);
  console.log("[HUD] Applied DEBUG visibility fixes and font styling");
})();

// Expose debug function globally
window.debugHUDForce();

console.log("[HUD FRAME] Enhanced HUD with boss mode support initialized successfully!");
