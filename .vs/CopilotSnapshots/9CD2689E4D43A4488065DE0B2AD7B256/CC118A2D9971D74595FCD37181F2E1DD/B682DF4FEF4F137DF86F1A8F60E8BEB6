// src/main.js
import { state, updateCanvasSize } from "../core/state.js";
import { constants } from "./constants.js";

// CRITICAL: Expose state globally for HUD updater
if (typeof window !== "undefined") {
  window.state = state;
  console.log("[main] Global state exposed for HUD updater");
}

import { loadAllResources, verifyBossAssets } from "./loader.js";
import { GameScene } from "./GameScene.js";
import { gameLoopFactory } from "./loop.js";
import { attachKeyboard } from "./keyboard.js";
import { attachPointer } from "./pointer.js";
import { initNapalmState, triggerNapalmStrike } from "./napalm.js";

// Enhanced RPG HUD with dynamic effects
import { dynamicFrameEffects } from "./dynamicFrameEffects.js";

// Preflight deps
import { resources } from "./resources.js";
import { bossDefinitions } from "./boss.js";
import { verifyResources } from "./preflight.js";

console.log("[main] script loaded");

// --- Optimized resize debounce (core-level) ---
const debounceResize = (() => {
  let timeoutId;
  const cache = new Map();
  return (fn, wait = 200) => {
    const key = fn.toString();
    if (cache.has(key)) return cache.get(key);
    
    const debouncedFn = (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(null, args), wait);
    };
    
    cache.set(key, debouncedFn);
    return debouncedFn;
  };
})();

// --- Optimized DOM creation with templates ---
const createElementFromTemplate = (() => {
  const templateCache = new Map();
  
  return (templateHTML, id) => {
    let template = templateCache.get(templateHTML);
    if (!template) {
      template = document.createElement('template');
      template.innerHTML = templateHTML;
      templateCache.set(templateHTML, template);
    }
    
    const element = template.content.cloneNode(true).firstElementChild;
    if (id) element.id = id;
    return element;
  };
})();

// Simple start screen check
function ensureStartScreen() {
  let s = document.getElementById('start-screen');
  if (s) {
    return s;
  }
  
  // Create fallback start screen
  const template = `<div id="start-screen" class="screen-container-4x3">
    <h1>JUNGLE SIEGE</h1>
    <h2>Iron Signal Works Presents</h2>
    <button id="start-button" disabled>CHAOS LOADING...</button>
  </div>`;
  
  document.body.insertAdjacentHTML('beforeend', template);
  return document.getElementById('start-screen');
}

// Simple HUD creation
function ensureFrameHud() {
  let hud = document.getElementById('screen-hud');
  if (!hud) {
    const template = `<div id="screen-hud">
      <div class="hud-top">
        <div class="cluster left">
          <div class="tag"><span class="lbl">ROUND</span><span id="hud-round" class="val">01</span></div>
          <div class="tag"><span class="lbl">SECTOR</span><span id="hud-sector" class="val">ALPHA</span></div>
        </div>
        <div class="cluster right">
          <div class="tag"><span class="lbl">OBJECTIVE</span><span id="hud-objective" class="val">SECURE PERIMETER</span></div>
        </div>
      </div>
      <div class="hud-bottom">
        <div class="hud-seg hp">
          <span class="hud-label">HP</span>
          <div class="hp-bar">
            <div class="hp-fill" id="hud-hp-fill" style="width:100%"></div>
          </div>
          <span class="hud-value" id="hud-health-value">100</span>
        </div>
        <div class="hud-seg ammo">
          <span class="hud-label">AMMO</span>
          <div class="pips" id="hud-ammo-pips">
            <div class="pip on"></div>
            <div class="pip on"></div>
            <div class="pip on"></div>
            <div class="pip on"></div>
            <div class="pip on"></div>
            <div class="pip on"></div>
          </div>
          <span class="hud-value" id="hud-ammo-value">50</span>
        </div>
        <div class="hud-seg score">
          <span class="hud-label">SCORE</span>
          <span class="hud-value" id="hud-score">000000</span>
        </div>
      </div>
      <div id="boss-hud" class="boss-hud" style="display: none;">
        <div class="boss-name">
          <span id="boss-name-text">BOSS NAME</span>
        </div>
        <div class="boss-hp-bar">
          <div class="boss-hp-fill" id="boss-hp-fill" style="width: 100%;"></div>
          <span class="boss-hp-text" id="boss-hp-text">1000/1000</span>
        </div>
      </div>
    </div>`;
    
    hud = createElementFromTemplate(template, 'screen-hud');
    
    // Append to game viewport
    const gameViewport = document.getElementById('game-viewport');
    if (gameViewport) {
      gameViewport.appendChild(hud);
    } else {
      document.body.appendChild(hud);
    }
    
    console.log("[main] Created HUD with proper element structure");
  }
  
  // Show HUD and set initial values
  hud.classList.remove('hidden');
  hud.removeAttribute('aria-hidden');
  //  hud.style.display = 'block';
  //  hud.style.opacity = '1';
  // Avoid setting inline styles that can override CSS or block input.
  // Use classes only; CSS controls visibility and pointer-events.
  hud.classList.add('visible');

  // Force initial values update
  const healthValue = document.getElementById('hud-health-value');
  const ammoValue = document.getElementById('hud-ammo-value');
  const scoreValue = document.getElementById('hud-score');
  const roundValue = document.getElementById('hud-round');
  const sectorValue = document.getElementById('hud-sector');

  if (healthValue) healthValue.textContent = '100';
  if (ammoValue) ammoValue.textContent = '50';
  if (scoreValue) scoreValue.textContent = '000000';
  if (roundValue) roundValue.textContent = '01';
  if (sectorValue) sectorValue.textContent = 'ALPHA';
  
  console.log("[main] HUD initialized with values:", {
    health: healthValue?.textContent,
    ammo: ammoValue?.textContent,
    score: scoreValue?.textContent,
    round: roundValue?.textContent,
    sector: sectorValue?.textContent
  });
  
  return hud;
}

// Create end screen
function createEndScreen(type = 'victory') {
  const endScreen = document.createElement('div');
  endScreen.id = 'end-screen';
  endScreen.className = 'screen-container-4x3';
  
  const title = type === 'victory' ? 'VICTORY!' : 'GAME OVER';
  const titleColor = type === 'victory' ? '#c7ffc7' : '#ff4d4d';
  const borderColor = type === 'victory' ? '#c7ffc7' : '#ff6b6b';
  
  endScreen.style.border = `2px solid ${borderColor}`;
  endScreen.style.boxShadow = `0 0 25px ${borderColor}33`;
  
  endScreen.innerHTML = `
    <h1 style="color:${titleColor};font-size:clamp(2rem,6vw,4rem);margin:1rem auto;text-transform:uppercase;text-shadow:0 0 15px ${titleColor};">${title}</h1>
    <div id="end-stats" style="margin:1rem auto;">
      <div style="color:#ffc107;font-size:clamp(1rem,3vw,2rem);margin:0.5rem auto;">FINAL SCORE: <span id="final-score">0</span></div>
      <div style="color:#ffc107;font-size:clamp(0.8rem,2.5vw,1.5rem);margin:0.5rem auto;opacity:0.9;">BEST: <span id="best-score">0</span></div>
    </div>
    <button id="restart-button">PLAY AGAIN</button>
  `;
  
  return endScreen;
}

// Simple game start
function startGame(scene, { startScreen, canvas } = {}) {
  console.log("[main] startGame() - State at start:", {
    health: state.health,
    ammo: state.ammo,
    score: state.score,
    round: state.round
  });
  
  // Remove any existing canvas
  const existingCanvas = document.getElementById("gameCanvas");
  if (existingCanvas) {
    existingCanvas.remove();
  }
  
  // Create canvas
  const stage = document.getElementById('stage');
  if (!stage) {
    console.error("Stage element not found!");
    return;
  }
  
  const c = document.createElement("canvas");
  c.id = "gameCanvas";
  c.width = 800;
  c.height = 600;
  c.className = "active";
  
  stage.appendChild(c);
  state.canvas = c;
  
  // Get context
  state.ctx = state.canvas.getContext("2d", {
    alpha: false,
    desynchronized: true,
    powerPreference: "high-performance"
  });

  // Hide start screen
  if (startScreen) {
    startScreen.classList.add("fade-out");
    setTimeout(() => {
      startScreen.style.display = "none";
    }, 500);
  }
  
  // Show HUD - CRITICAL FOR HUD UPDATES
  const frameHud = document.getElementById("screen-hud");
  if (frameHud) {
    frameHud.classList.remove('hidden');
    frameHud.removeAttribute('aria-hidden');
    // Do not set inline styles (display/visibility) which may block the page.
    frameHud.classList.add('visible');
    console.log("[main] HUD made visible (no inline styles)");
    
    // Force update HUD elements immediately
    setTimeout(() => {
      const healthEl = document.getElementById('hud-health-value');
      const ammoEl = document.getElementById('hud-ammo-value');
      const scoreEl = document.getElementById('hud-score');
      
      if (healthEl) healthEl.textContent = String(state.health);
      if (ammoEl) ammoEl.textContent = state.ammo === Infinity ? '∞' : String(state.ammo);
      if (scoreEl) scoreEl.textContent = String(state.score).padStart(6, '0');
      
      console.log("[main] Force updated HUD values:", {
        health: healthEl?.textContent,
        ammo: ammoEl?.textContent,
        score: scoreEl?.textContent
      });
    }, 100);
  } else {
    console.warn("[main] screen-hud element not found");
  }

  // Initialize enhanced frame effects
  try {
    if (dynamicFrameEffects && !dynamicFrameEffects.isInitialized) {
      dynamicFrameEffects.init();
      console.log("[main] Dynamic frame effects initialized");
    }
  } catch (e) {
    console.warn("[main] Dynamic frame effects failed to initialize:", e);
  }

  // Input
  attachPointer();
  attachKeyboard();

  // Initialize game state
  state.tank = state.tank || { x: 0, y: 0, width: 64, height: 64 };
  state.health = 100;    // Initialize health
  
  // Fix ammo initialization based on constants
  if (constants?.ammoInfinite) {
    state.ammo = Infinity;
    console.log("[main] Set infinite ammo");
  } else {
    state.ammo = constants?.startingAmmo || 50;
    console.log("[main] Set finite ammo:", state.ammo);
  }
  
  state.score = 0;       // Initialize score
  state.round = 1;       // FORCE START AT ROUND 1
  state.sector = 'ALPHA'; // FORCE START AT SECTOR ALPHA (English name)
  state.bossIndex = 0;   // FORCE START AT FIRST BOSS
  state.gameStarted = true; // CRITICAL: Set this flag for HUD visibility
  
  updateCanvasSize({ keepTankPosition: false });
  
  state.tank.x = Math.max(0, (state.canvas.width / 2) - (state.tank.width / 2));
  state.tank.y = Math.max(0, state.canvas.height - 100);

  console.log("[main] Game state initialized:", {
    health: state.health,
    ammo: state.ammo,
    score: state.score,
    round: state.round,
    sector: state.sector,
    bossIndex: state.bossIndex,
    gameStarted: state.gameStarted
  });
  
  // Initialize systems
  try { 
    initNapalmState(); 
  } catch (e) { 
    console.warn("initNapalmState failed", e); 
  }

  // Enter scene
  if (scene?.enter) { 
    try { 
      scene.enter(); 
    } catch (e) { 
      console.error("Scene enter() failed:", e); 
    } 
  }

  // Game loop with enhanced effects
  if (!state._gameLoop) {
    let lastFrameTime = 0;
    
    state._gameLoop = gameLoopFactory(
      (now) => { 
        try { 
          // FIXED: Always call update, don't throttle based on deltaTime
          // The original code was preventing updates from running frequently enough
          scene?.update?.(now);
          lastFrameTime = now;
        } catch (e) { 
          console.error("update() crash:", e); 
        } 
      },
      (now) => { 
        try { 
          scene?.render?.(now); 
        } catch (e) { 
          console.error("render() crash:", e); 
        } 
      }
    );
    requestAnimationFrame(state._gameLoop);
  }

  // Resize handling
  const resizeHandler = debounceResize(() => updateCanvasSize({ keepTankPosition: true }), 150);
  window.addEventListener("resize", resizeHandler, { passive: true });

  // Event listeners with enhanced effects
  const keydownHandler = (e) => {
    if (e.code === "KeyN") { 
      try { 
        triggerNapalmStrike();
        // Trigger special effect for napalm
        dynamicFrameEffects?.triggerEffect('powerup');
      } catch (err) { 
        console.warn("napalm N failed", err); 
      } 
    }
  };
  
  const pointerHandler = () => {
    try { 
      triggerNapalmStrike();
      // Trigger special effect for napalm
      dynamicFrameEffects?.triggerEffect('electrical');
    } catch (err) { 
      console.warn("napalm touch failed", err); 
    }
  };

  window.addEventListener("keydown", keydownHandler, { passive: true });
  state.canvas.addEventListener("pointerdown", pointerHandler, { passive: true });

  // Hook into game events for visual effects
  const originalUpdateHUD = window.updateHUD;
  window.updateHUD = function(...args) {
    const prevHealth = state.health;
    const prevScore = state.score;
    
    if (originalUpdateHUD) {
      originalUpdateHUD.apply(this, args);
    }
    
    // Trigger effects based on state changes
    if (state.health < prevHealth) {
      const damageIntensity = (prevHealth - state.health) / 100;
      dynamicFrameEffects?.triggerEffect('damage', damageIntensity);
    }
    
    if (state.score > prevScore) {
      const scoreGain = state.score - prevScore;
      if (scoreGain >= 1000) {
        dynamicFrameEffects?.triggerEffect('critical');
      }
    }
    
    if (state.health <= 20) {
      dynamicFrameEffects?.triggerEffect('warning');
    }
  };
}

// expose restart hooks for screens.js
window.__startGame = startGame;
window.restartGame = () => {
  try {
    // Clear overlays
    const end = document.getElementById("end-screen");
    if (end) end.remove();

    // Cleanup dynamic effects
    try {
      dynamicFrameEffects?.destroy();
    } catch (e) {
      console.warn("Error cleaning up dynamic effects:", e);
    }

    // Recreate a fresh scene and start
    import("./scenes/GameScene.js").then(({ GameScene: GameSceneMod }) => {
      const scene = new GameSceneMod();
      const startScreen = document.getElementById("start-screen");
      const canvas = document.getElementById("gameCanvas");
      window.__startGame(scene, { startScreen, canvas });
    });
  } catch (e) {
    console.error("[main] restartGame failed, fallback reload:", e);
    location.reload();
  }
};

// Expose dynamic effects for external use
if (typeof window !== "undefined") {
  window.dynamicFrameEffects = dynamicFrameEffects;
}

// Critical asset computation
const computeCritical = (() => {
  let cachedResult = null;
  
  return () => {
    if (cachedResult) return cachedResult;
    
    const criticalImages = new Set([
      "bg_intro.png",
      ...bossDefinitions.flatMap(b => [b.image, b.backdrop, b.projectileType].filter(Boolean))
    ]);
    
    cachedResult = { 
      criticalImages: [...criticalImages], 
      criticalAudio: [] 
    };
    
    return cachedResult;
  };
})();

function showCriticalOverlay(critMissing) {
  const overlay = document.createElement("div");
  overlay.style.cssText = "position:fixed;inset:0;background:#111;color:#f66;padding:24px;font:14px/1.4 monospace;overflow:auto;z-index:99999;";
  
  const missingAssets = [
    ...critMissing.images.map(k => `images/${k}`),
    ...critMissing.audio.map(k => `audio/${k}`)
  ];
  
  overlay.innerHTML = `<h2>Missing critical assets</h2>
    <p>Fix the files below (path is relative to site root):</p>
    <pre>${missingAssets.join("\n")}</pre>`;
  
  document.body.appendChild(overlay);
}

// Preflight check
async function runPreflight() {
  console.info("[main] preflight check starting…");
  const { criticalImages, criticalAudio } = computeCritical();

  try {
    const { missing, critMissing } = await verifyResources(resources, {
      timeoutMs: 12000,
      criticalImages,
      criticalAudio,
      onProgress: (n, total) => {
        if (n === total || n % 10 === 0) {
          console.log(`[preflight] ${n}/${total}`);
        }
      },
    });

    if (missing.images.length || missing.audio.length) {
      console.warn("[preflight] Missing (any):", missing);
    }
    
    if (critMissing.images.length || critMissing.audio.length) {
      console.warn("[preflight] CRITICAL missing (non-blocking):", critMissing);
    }
    
    console.info("[preflight] OK");
    return { ok: true };
  } catch (error) {
    console.error("[preflight] Check failed:", error);
    return { ok: false, error };
  }
}

// Debug function
window.debugPositioning = function() {
  console.log("=== POSITIONING DEBUG ===");
  
  const elements = ['start-screen', 'game-viewport', 'stage', 'gameCanvas', 'screen-hud'];
  elements.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      const rect = el.getBoundingClientRect();
      const computed = window.getComputedStyle(el);
      console.log(`${id}:`, {
        position: computed.position,
        left: computed.left,
        top: computed.top,
        transform: computed.transform,
        width: rect.width,
        height: rect.height,
        aspectRatio: (rect.width / rect.height).toFixed(3),
        rect: rect
      });
    }
  });
  
  console.log("Viewport:", {
    width: window.innerWidth,
    height: window.innerHeight,
    aspectRatio: (window.innerWidth / window.innerHeight).toFixed(3)
  });
  
  const expected4x3Width = Math.min(window.innerWidth, window.innerHeight * 4/3);
  const expected4x3Height = expected4x3Width * 3/4;
  console.log("Expected 4:3:", {
    width: expected4x3Width,
    height: expected4x3Height,
    aspectRatio: (expected4x3Width / expected4x3Height).toFixed(3)
  });
};

// Debug HUD state
window.debugHUD = function() {
  console.log("=== HUD DEBUG ===");
  console.log("Game State:", {
    health: state.health,
    ammo: state.ammo,
    score: state.score,
    round: state.round,
    sector: state.sector,
    gameStarted: state.gameStarted
  });
  
  const hudElements = ['hud-round', 'hud-sector', 'hud-score', 'hud-hp-fill', 'hud-health-value', 'hud-ammo-value', 'hud-ammo-pips'];
  hudElements.forEach(id => {
    const el = document.getElementById(id);
    console.log(`${id}:`, el ? {
      textContent: el.textContent,
      style: el.style.cssText,
      visible: el.offsetParent !== null,
      computed: window.getComputedStyle(el).display
    } : 'NOT FOUND');
  });
};

// Debug function to manually test HUD updates
window.testHUD = function() {
  console.log("Testing HUD updates...");
  
  // Manually update state
  if (window.state) {
    window.state.health = 75;
    window.state.ammo = 25;
    window.state.score = 1250;
    window.state.round = 3;
    window.state.sector = 'BETA';
    
    console.log("Updated state:", {
      health: window.state.health,
      ammo: window.state.ammo,
      score: window.state.score,
      round: window.state.round,
      sector: window.state.sector
    });
  }
};

// Force show HUD function
window.forceShowHUD = function() {
  const hudEl = document.getElementById('screen-hud');
  if (hudEl) {
    hudEl.classList.remove('hidden');
    hudEl.removeAttribute('aria-hidden');
    hudEl.style.display = 'block';
    hudEl.style.opacity = '1';
    hudEl.style.visibility = 'visible';
    hudEl.style.zIndex = '1000';
    console.log("HUD forced visible");
    
    // Also force game state
    if (window.state) {
      window.state.gameStarted = true;
      console.log("Game state forced to started");
    }
  } else {
    console.log("HUD element not found");
  }
};

// Game initialization
async function initGame() {
  console.log("[main] initGame()");
  
  // Debug positioning after DOM is ready
  setTimeout(() => {
    console.log("Initial positioning:");
    window.debugPositioning();
  }, 500);
  
  const [frameHud] = await Promise.all([
    Promise.resolve(ensureFrameHud()),
  ]);
  
  const startScreen = document.getElementById("start-screen") || ensureStartScreen();
  let startBtn = document.getElementById("start-button") || 
                 startScreen?.querySelector("#start-button");
                 
  if (!startBtn && startScreen) {
    startBtn = Object.assign(document.createElement("button"), {
      id: "start-button",
      disabled: true,
      textContent: "CHAOS LOADING..."
    });
    startScreen.appendChild(startBtn);
  }
  
  const canvas = document.getElementById("gameCanvas");

  // Initial updates
  if (canvas) canvas.style.display = "none";
  if (startBtn) {
    Object.assign(startBtn, {
      disabled: true,
      textContent: "CHECKING ASSETS…"
    });
  }

  // Preflight check
  const pre = await runPreflight();
  if (!pre.ok) {
    if (startBtn) {
      Object.assign(startBtn, {
        disabled: true,
        textContent: "MISSING ASSETS"
      });
    }
    return;
  }

  // Resource loading with safety timeout
  const totalAssets = 
    (Object.keys(resources.images || {}).length +
     Object.keys(resources.audio || {}).length);
     
  const safetyMs = Math.min(8000, 2000 + totalAssets * 40);
  
  let safetyTimeout = setTimeout(() => {
    if (startBtn?.disabled) {
      console.warn("[main] loader safety trip → enabling START anyway");
      Object.assign(startBtn, {
        disabled: false,
        textContent: "START"
      });
    }
  }, safetyMs);

  try {
    let lastProgressUpdate = 0;
    
    await loadAllResources(bossDefinitions, (progress) => {
      const now = performance.now();
      
      if (safetyTimeout) { 
        clearTimeout(safetyTimeout); 
        safetyTimeout = null; 
      }
      
      if (startBtn && typeof progress === "number" && 
          (now - lastProgressUpdate > 100 || progress === 1)) {
        startBtn.textContent = `LOADING… ${Math.round(progress * 100)}%`;
        lastProgressUpdate = now;
      }
    });
    
    state.resourcesLoaded = true;
    console.log("[main] resources loaded");

    try { 
      verifyBossAssets(); 
    } catch (e) { 
      console.warn("verifyBossAssets reported issues:", e); 
    }
  } catch (err) {
    console.error("[main] loadAllResources failed:", err);
    if (startBtn) { 
      startBtn.textContent = "START (assets failed)"; 
    }
  } finally {
    if (safetyTimeout) { 
      clearTimeout(safetyTimeout); 
      safetyTimeout = null; 
    }
  }

  const scene = new GameScene();

  // Wire START button
  if (startBtn) {
    Object.assign(startBtn, {
      disabled: false,
      textContent: "START"
    });
    
    startBtn.onclick = (e) => {
      e.preventDefault();
      startGame(scene, { startScreen, canvas });
    };
  } else {
    startGame(scene, { startScreen, canvas });
  }
}

// Error handling
initGame().catch(e => {
  console.error("[main] init crash:", e);
  
  const errorDiv = document.createElement('div');
  errorDiv.className = 'screen-container-4x3';
  errorDiv.style.cssText = `
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    background: rgba(0,0,0,0.9);
    color: #f00;
    font-family: monospace;
    z-index: 99999;
    border: 2px solid #ff6b6b;
    box-shadow: 0 0 25px rgba(255,107,107,0.3);
  `;
  
  const errorContent = document.createElement('div');
  errorContent.style.cssText = `
    background: #222;
    padding: 1.5rem;
    border-radius: 10px;
    border: 2px solid #ff6b6b;
    max-width: 80%;
    text-align: center;
  `;
  errorContent.innerHTML = `
    <h2 style="margin:0 0 1rem 0;color:#ff6b6b;">Initialization Failed</h2>
    <p style="margin:0 0 1.5rem 0;color:#fff;">Error: ${e.message}</p>
    <button onclick="location.reload()" style="font-family:inherit;padding:0.8em 1.5em;background:#ff6b6b;color:#fff;border:none;border-radius:8px;cursor:pointer;">Reload Game</button>
  `;
  
  errorDiv.appendChild(errorContent);
  document.body.appendChild(errorDiv);
});
