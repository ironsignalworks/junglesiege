// --- tiny resize debounce (core-level) ---
const debounceResize = (fn, wait = 200) => {
  let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn.apply(null, a), wait); };
};

// src/main.js
import { state, updateCanvasSize } from "./core/state.js";
if (typeof window !== "undefined") window.state = state;
import { loadAllResources, verifyBossAssets } from "./assets/loader.js";
import GameScene from "./scenes/GameScene.js";
import { gameLoopFactory } from "./core/loop.js";
import { attachKeyboard } from "./input/keyboard.js";
import { attachPointer } from "./input/pointer.js";
import { initNapalmState, triggerNapalmStrike } from "./systems/napalm.js";

// Preflight deps

function ensureStartScreen(){let s=document.getElementById('start-screen');if(!s){s=document.createElement('section');s.id='start-screen';s.innerHTML=`<div class="start-card"><h1 style="margin:0 0 .5em;text-align:center;letter-spacing:.12em;">JUNGLE SIEGE</h1><p style="margin:.5em 0 1em;opacity:.85;text-align:center;">Arcade survival. Move, aim, survive.</p><div style="display:flex;justify-content:center;"><button id="start-button" disabled>LOADING…</button></div></div>`;document.body.appendChild(s);}return s;}
import { resources } from "./assets/resources.js";
import { bossDefinitions } from "./systems/boss.js";
import { verifyResources } from "./systems/preflight.js";

console.log("[main] script loaded");

// Idempotent main handlers to avoid duplicate listeners across restarts
window.__main_handlers = window.__main_handlers || {};
const __mh = window.__main_handlers;
if (!__mh.resizeHandler) {
  __mh.resizeHandler = debounceResize(() => updateCanvasSize({ keepTankPosition: true }), 150);
}
if (!__mh.keydownHandler) {
  __mh.keydownHandler = (e) => {
    if (e.code === "KeyN") {
      try { triggerNapalmStrike(); } catch (err) { console.warn("napalm N failed", err); }
    }
  };
}
if (!__mh.canvasPointerHandler) {
  __mh.canvasPointerHandler = () => {
    try { triggerNapalmStrike(); } catch (err) { console.warn("napalm touch failed", err); }
  };
}
__mh.attached = __mh.attached || false;

// Ensure the frame HUD exists and is visible
function ensureFrameHud() {
  let hud = document.getElementById('screen-hud');
  if (!hud) {
    const wrapper = document.createElement('div');
    wrapper.id = 'screen-hud';
    wrapper.innerHTML = `
  <div class="hud-top">
    <div class="cluster left">
      <div class="tag"><span class="lbl">ROUND</span><span id="hud-round" class="val">1</span></div>
      <div class="tag"><span class="lbl">SECTOR</span><span id="hud-sector" class="val">A</span></div>
    </div>
    <div class="cluster right">
      <div class="tag"><span class="lbl">OBJECTIVE</span><span id="hud-objective" class="val">HOLD THE LINE</span></div>
    </div>
  </div>
  <div class="hud-bottom">
    <div class="hud-seg hp">
      <span class="hud-label">HP</span>
      <div class="hp-bar"><div class="hp-fill" id="hud-hp-fill" style="width:70%"></div></div>
    </div>
    <div class="hud-seg ammo">
      <span class="hud-label">AMMO</span>
      <div class="pips" id="hud-ammo-pips"></div>
    </div>
    <div class="hud-seg score">
      <span class="hud-label">SCORE</span>
      <span class="hud-value" id="hud-score">000000</span>
    </div>
  </div>`;
    document.body.appendChild(wrapper);
    hud = wrapper;
  }
  try { hud.removeAttribute('aria-hidden'); hud.classList.remove('hidden'); } catch {}
  return hud;
}

function startGame(scene, { startScreen, canvas } = {}) {document.body.classList.add('game-started');
  console.log("[main] startGame()");
  state.canvas = canvas ?? document.getElementById("gameCanvas");
  if (!state.canvas) {
    const c = document.createElement("canvas");
    c.id = "gameCanvas";
    c.width = 800; c.height = 600;
    const stageHost = document.getElementById('stage') || document.body;
    stageHost.appendChild(c);
    state.canvas = c;
  }
  state.ctx = state.canvas.getContext("2d");

  // Show canvas / hide start (fade out)
  if (startScreen) {
    startScreen.classList?.add?.("fade-out");
    startScreen.style.display = "none";
  }
  // Ensure frame HUD is visible when game starts
  try {
    const frameHud = document.getElementById("screen-hud");
    if (frameHud) {
      frameHud.removeAttribute("aria-hidden");
      frameHud.classList.remove("hidden");
    }
    document.body.classList.add("game-started");
  } catch {}
  state.canvas.style.display = "block";

  // Input (idempotent attachers)
  attachPointer();
  attachKeyboard();

  // Player seed
  state.tank = state.tank || { x: 0, y: 0, width: 64, height: 64 };
  state.tank.x = Math.max(0, (state.canvas.width / 2) - (state.tank.width / 2));
  state.tank.y = Math.max(0, state.canvas.height - 100);

  state.gameStarted = true;
  try { initNapalmState(); } catch (e) { console.warn("initNapalmState failed", e); }

  // Enter scene
  if (scene?.enter) { try { scene.enter(); } catch (e) { console.error("Scene enter() failed:", e); } }

  // RAF once
  if (!state._gameLoop) {
    state._gameLoop = gameLoopFactory(
      (now) => { try { scene?.update?.(now); } catch (e) { console.error("update() crash:", e); } },
      (now) => { try { scene?.render?.(now); } catch (e) { console.error("render() crash:", e); } }
    );
    requestAnimationFrame(state._gameLoop);
  }

  // Attach size handler and global napalm input handlers idempotently
  updateCanvasSize({ keepTankPosition: true });
  if (!__mh.attached) {
    window.addEventListener("resize", __mh.resizeHandler);
    window.addEventListener("keydown", __mh.keydownHandler);
    __mh.attached = true;
  }
  // Ensure the canvas has the pointer handler attached (canvas object may be new)
  if (!state.canvas._napalmPointerAttached) {
    state.canvas.addEventListener("pointerdown", __mh.canvasPointerHandler);
    state.canvas._napalmPointerAttached = true;
  }
}

// expose restart hooks for screens.js
window.__startGame = startGame;
window.restartGame = () => {
  try {
    // Clear overlays
    const end = document.getElementById("end-screen");
    if (end) end.remove();

    // Recreate a fresh scene and start (reusing existing canvas & hiding start screen)
    import("./scenes/GameScene.js").then(({ default: GameSceneMod }) => {
      const scene = new GameSceneMod();
      const startScreen = document.getElementById("start-screen");
      const canvas = document.getElementById("gameCanvas");
      window.__startGame(scene, { startScreen, canvas });
    });
  } catch (e) {
    console.error("[main] restartGame failed, fallback reload:", e);
    location.reload();
  }
};

function computeCritical() {
  // Boss portraits & backdrops & projectileType are critical
  const img = new Set([
    "bg_intro.png",
    ...bossDefinitions.map(b => b.image),
    ...bossDefinitions.map(b => b.backdrop),
    ...bossDefinitions.map(b => b.projectileType),
  ].filter(Boolean));
  return { criticalImages: [...img], criticalAudio: [] };
}

function showCriticalOverlay(critMissing) {
  const overlay = document.createElement("div");
  overlay.style.cssText = "position:fixed;inset:0;background:#111;color:#f66;padding:24px;font:14px/1.4 monospace;overflow:auto;z-index:99999;";
  const body = [
    ...critMissing.images.map(k => `images/${k}`),
    ...critMissing.audio.map(k => `audio/${k}`)
  ].join("\n");
  overlay.innerHTML = `<h2>Missing critical assets</h2>
    <p>Fix the files below (path is relative to site root):</p>
    <pre>${body}</pre>`;
  document.body.appendChild(overlay);
}

async function runPreflight() {
  console.info("[main] preflight check starting…");
  const { criticalImages, criticalAudio } = computeCritical();

  const { missing, critMissing } = await verifyResources(resources, {
    timeoutMs: 12000,
    criticalImages,
    criticalAudio,
    onProgress: (n, total) => {
      if (n === total || n % 10 === 0) console.log(`[preflight] ${n}/${total}`);
    },
  });

  if (missing.images.length || missing.audio.length) {
    console.warn("[preflight] Missing (any):", missing);
  }
  if (critMissing.images.length || critMissing.audio.length) {
    console.warn("[preflight] CRITICAL missing (non-blocking):", critMissing);
    // non-blocking: allow start; users reported transient misses that resolve on reload
  }
  console.info("[preflight] OK");
  return { ok: true };
}

async function initGame() {
  console.log("[main] initGame()");
  ensureFrameHud();
  const startScreen = document.getElementById("start-screen") || ensureStartScreen();
  let startBtn = document.getElementById("start-button") || (startScreen && startScreen.querySelector("#start-button"));
  if (!startBtn && startScreen) {
    const btn = document.createElement("button");
    btn.id = "start-button";
    btn.disabled = true;
    btn.textContent = "LOADING…";
    startScreen.appendChild(btn);
    startBtn = btn;
  }
  const canvas = document.getElementById("gameCanvas");

  if (canvas) canvas.style.display = "none";
  if (startBtn) {
    startBtn.disabled = true;
    startBtn.textContent = "CHECKING ASSETS…";
  }

  // 1) Preflight first (can hard-block start)
  const pre = await runPreflight();
  if (!pre.ok) {
    if (startBtn) {
      startBtn.disabled = true;
      startBtn.textContent = "MISSING ASSETS";
    }
    return; // stop here
  }

  // 2) Adaptive loader safety (for resource loader only)
  const totalAssets =
    Object.keys(resources.images || {}).length +
    Object.keys(resources.audio || {}).length;
  const safetyMs = Math.min(8000, 2000 + totalAssets * 40); // adaptive, capped
  let safety = setTimeout(() => {
    if (startBtn && startBtn.disabled) {
      console.warn("[main] loader safety trip → enabling START anyway");
      startBtn.disabled = false;
      startBtn.textContent = "START";
    }
  }, safetyMs);

  // 3) Load resources (images/audio decoding etc.)
  try {
    // If your loader supports a progress callback, this updates the button
    await loadAllResources(bossDefinitions, (progress) => {
      if (safety) { clearTimeout(safety); safety = null; } // first sign of progress cancels safety
      if (startBtn && typeof progress === "number") {
        startBtn.textContent = `LOADING… ${Math.round(progress * 100)}%`;
      }
    });
    state.resourcesLoaded = true;
    console.log("[main] resources loaded");

    // 4) Deep-verify boss assets (types, previous 404s, etc.)
    try { verifyBossAssets(); } catch (e) { console.warn("verifyBossAssets reported issues:", e); }
  } catch (err) {
    console.error("[main] loadAllResources failed:", err);
    if (startBtn) { startBtn.textContent = "START (assets failed)"; }
  } finally {
    if (safety) { clearTimeout(safety); safety = null; }
  }

  const scene = new GameScene();

  // 5) Wire START
  if (startBtn) {
    startBtn.disabled = false;
    startBtn.textContent = "START";
    startBtn.onclick = (e) => {
      e.preventDefault();
      startGame(scene, { startScreen, canvas });
    };
  } else {
    // Fallback: auto-start if no button exists
    startGame(scene, { startScreen, canvas });
  }
}

// Single entry point
initGame().catch(e => console.error("[main] init crash:", e));
